<!DOCTYPE html>
<html>
  <head>
    <!--
    これはHC4, 4e, HC8シリーズ用のビジュアルアセンブラです.
    わかりやすいブロックによってアセンブリ言語を書くことができます.
    -->
    <meta charset="utf-8">
    <title>HCx Series Visual Assembler</title>
    <!-- Blockly本体の読み込み（オンライン版） -->
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
      html, body { height: 100%; margin: 0; }
      #blocklyDiv { height: 70%; width: 100%; }
      #output {
        height: 180px;
        width: 100%;
        border-top: 1px solid #ccc;
        font-family: monospace;
        white-space: pre;
        background: #fff;
        overflow-y: auto;
        box-sizing: border-box;
      }
      #blocklyDiv {
        height: calc(100vh - 220px);
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h3>HCx シリーズ ビジュアルアセンブラ</h3>
    <div style="margin-bottom: 10px;">
      <button id="saveButton" onclick="saveAssemblyFile()">アセンブリファイルを保存</button>
    </div>
    <!-- Blocklyエディタを置く場所 -->
    <div id="blocklyDiv"></div>
    <!-- 出力結果表示エリア -->
    <div id="output"></div>

    <!-- ラベル入力ダイアログ -->
    <div id="labelDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 9999;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 5px; min-width: 300px;">
        <h4>新しいラベルを作成</h4>
        <p>新しいラベル名を入力してください:</p>
        <input type="text" id="labelInput" style="width: 100%; padding: 5px; margin: 10px 0;" />
        <div style="text-align: right; margin-top: 15px;">
          <button onclick="cancelLabelCreation()" style="margin-right: 10px;">キャンセル</button>
          <button onclick="confirmLabelCreation()">OK</button>
        </div>
      </div>
    </div>

    <script>
      // --- 独自ブロック定義 ---
      // --- DICTHC4命令すべてのブロック定義 ---
      // 汎用: 引数なし
      function makeNoArgBlock(type, label, color) {
        Blockly.Blocks[type] = {
          init: function() {
            this.appendDummyInput().appendField(label);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(color);
          }
        };
      }
      // 汎用: 即値
      function makeImmBlock(type, label, color) {
        Blockly.Blocks[type] = {
          init: function() {
            this.appendDummyInput()
                .appendField(label + ' #')
                .appendField(new Blockly.FieldNumber(0, 0, 255), "VALUE");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(color);
          }
        };
      }
      // 汎用: フラグ
      function makeFlagBlock(type, label, color) {
        Blockly.Blocks[type] = {
          init: function() {
            this.appendDummyInput()
                .appendField(label)
                .appendField(new Blockly.FieldDropdown([
                  [" ", " "],
                  ["C", "C"],
                  ["NC", "NC"],
                  ["Z", "Z"],
                  ["NZ", "NZ"]
                ]), "FLAG");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(color);
          }
        };
      }

      function makeRegisterBlock(type, label, color) {
        Blockly.Blocks[type] = {
          init: function() {
            this.appendDummyInput()
                .appendField(label)
                .appendField(new Blockly.FieldDropdown([
                  ["R0", "R0"],
                  ["R1", "R1"],
                  ["R2", "R2"],
                  ["R3", "R3"],
                  ["R4", "R4"],
                  ["R5", "R5"],
                  ["R6", "R6"],
                  ["R7", "R7"],
                  ["R8", "R8"],
                  ["R9", "R9"],
                  ["R10", "R10"],
                  ["R11", "R11"],
                  ["R12", "R12"],
                  ["R13", "R13"],
                  ["R14", "R14"],
                  ["R15", "R15"]
                  ]), "REGISTER");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(color);
          }
        };
      }

      function makeGotoBlock(type, label, color) {
        Blockly.Blocks[type] = {
          init: function() {
            this.appendDummyInput()
                .appendField(label)
                .appendField(new Blockly.FieldDropdown(this.getLabelOptions.bind(this)), "LABEL");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(color);
          },
          
          getLabelOptions: function() {
            console.log('[DEBUG] getLabelOptions called');
            // 既存のラベルオプションを取得
            var options = [];
            
            // デフォルトのラベル
            if (window.customLabels && window.customLabels.length > 0) {
              window.customLabels.forEach(function(label) {
                options.push([label, label]);
              });
              console.log('[DEBUG] customLabels found:', window.customLabels);
            } else {
              options.push(['START', 'START']);
              console.log('[DEBUG] using default START label');
            }
            
            // 「新しいラベルを作成」オプションを追加
            options.push(['新しいラベルを作成...', 'CREATE_NEW']);
            console.log('[DEBUG] final options:', options);
            
            return options;
          },
          
          onchange: function(event) {
            console.log('[DEBUG] onchange event triggered:', event);
            if (event.type === Blockly.Events.BLOCK_CHANGE && 
                event.blockId === this.id && 
                event.element === 'field' && 
                event.name === 'LABEL') {
              
              console.log('[DEBUG] LABEL field change detected, newValue:', event.newValue);
              if (event.newValue === 'CREATE_NEW') {
                console.log('[DEBUG] CREATE_NEW selected, creating new label...');
                // 新しいラベル作成処理
                setTimeout(() => {
                  this.createNewLabel();
                }, 10);
              }
            }
          },
          
          createNewLabel: function() {
            console.log('[DEBUG] createNewLabel called');
            
            // 現在のブロックインスタンスを保存
            window.currentLabelBlock = this;
            
            // ダイアログを表示
            var dialog = document.getElementById('labelDialog');
            var input = document.getElementById('labelInput');
            input.value = 'LABEL' + (Date.now() % 1000);
            dialog.style.display = 'block';
            input.focus();
            input.select();
          },
          
          handleNewLabel: function(newLabel) {
            if (newLabel && newLabel.trim) {
              newLabel = newLabel.trim().toUpperCase();
              console.log('[DEBUG] processed label:', newLabel);
              
              // カスタムラベルリストを初期化（存在しない場合）
              if (!window.customLabels) {
                window.customLabels = ['START'];
                console.log('[DEBUG] initialized customLabels');
              }
              
              // 重複チェック
              if (window.customLabels.indexOf(newLabel) === -1) {
                window.customLabels.push(newLabel);
                console.log('[DEBUG] added new label, customLabels now:', window.customLabels);
              } else {
                console.log('[DEBUG] label already exists');
              }
              
              // すべてのJPブロックのドロップダウンを更新
              this.updateAllLabelBlocks();
              
              // 現在のブロックの値を新しいラベルに設定
              var field = this.getField('LABEL');
              if (field) {
                // メニューを再生成してから値を設定
                field.menuGenerator_ = this.getLabelOptions.bind(this);
                field.setValue(newLabel);
                console.log('[DEBUG] field value set to:', newLabel);
              }
            } else {
              console.log('[DEBUG] user cancelled or empty input');
              // キャンセルまたは空の場合、最初のラベルに戻す
              var field = this.getField('LABEL');
              if (field && window.customLabels && window.customLabels.length > 0) {
                field.setValue(window.customLabels[0]);
                console.log('[DEBUG] reset to first label:', window.customLabels[0]);
              }
            }
          },
          
          updateAllLabelBlocks: function() {
            console.log('[DEBUG] updateAllLabelBlocks called');
            // ワークスペース内のすべてのラベルブロックを更新
            var workspace = this.workspace;
            var allBlocks = workspace.getAllBlocks();
            var self = this;
            console.log('[DEBUG] found', allBlocks.length, 'blocks in workspace');
            
            allBlocks.forEach(function(block) {
              if (block.type === self.type && block !== self) {
                console.log('[DEBUG] updating block:', block.id);
                var field = block.getField('LABEL');
                if (field) {
                  // メニューを強制的に再生成
                  field.menuGenerator_ = block.getLabelOptions.bind(block);
                  console.log('[DEBUG] updated menuGenerator for block:', block.id);
                }
              }
            });
          }
        };
      }

      // カスタムラベルを初期化
      window.customLabels = ['START', 'LOOP', 'END'];

      // 命令ごとにブロックを定義
      makeNoArgBlock('sm', 'SM', 60);
      makeRegisterBlock('sc', 'SC', 65);
      makeRegisterBlock('su', 'SU', 70);
      makeRegisterBlock('ad', 'AD', 75);
      makeRegisterBlock('xr', 'XR', 80);
      makeRegisterBlock('or', 'OR', 85);
      makeRegisterBlock('an', 'AN', 90);
      makeRegisterBlock('sa', 'SA', 95);
      makeNoArgBlock('lm', 'LM', 100);
      makeRegisterBlock('ld', 'LD', 105);
      makeImmBlock('li', 'LI', 110);
      makeFlagBlock('jp', 'JP', 120);
      makeNoArgBlock('np', 'NP', 125);

      // GOTO疑似命令
      makeGotoBlock('goto', 'GOTO', 130);

      // --- コード生成ルール（独自アセンブリ出力） ---
      Blockly.Assembly = new Blockly.Generator('Assembly');
      Blockly.Assembly.PRECEDENCE = 0;
      Blockly.Assembly.forBlock = Blockly.Assembly.forBlock || {};
        Blockly.Assembly.forBlock['sc'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'SC ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['su'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'SU ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['ad'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'AD ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['xr'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'XR ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['or'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'OR ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['an'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'AN ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['sa'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'SA ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['ld'] = function(block) {
          var reg = block.getFieldValue('REGISTER');
          return 'LD ' + reg + '\n';
        };
        Blockly.Assembly.forBlock['lm'] = function(block) { return 'LM\n'; };
        Blockly.Assembly.forBlock['li'] = function(block) {
          var value = block.getFieldValue('VALUE');
          return 'LI #' + value + '\n';
        };
        Blockly.Assembly.forBlock['jp'] = function(block) {
          var flag = block.getFieldValue('FLAG');
          return 'JP ' + flag + '\n';
        };
        Blockly.Assembly.forBlock['sm'] = function(block) { return 'SM\n'; };
        Blockly.Assembly.forBlock['np'] = function(block) { return 'NP\n'; };

        // GOTO用コード生成ルール
        
        Blockly.Assembly.forBlock['goto'] = function(block) {
          var label = block.getFieldValue('LABEL');
          return  'LI #' + label + ':2\n' +
                  'LI #' + label + ':1\n' +
                  'LI #' + label + ':0\n' +
                  'JP\n';
        };
        
      Blockly.Assembly.init = function(workspace) {};
      Blockly.Assembly.finish = function(code) { return code; };
      Blockly.Assembly.scrub_ = function(block, code) {
        var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
        var nextCode = nextBlock ? Blockly.Assembly.blockToCode(nextBlock) : '';
        return code + nextCode;
      };

      // --- ツールボックス（新しいJSON形式） ---
  // toolboxはDICTHC4命令用のみ定義
        const toolbox = {
          "kind": "flyoutToolbox",
          "contents": [
            { "kind": "block", "type": "sm" },
            { "kind": "block", "type": "sc" },
            { "kind": "block", "type": "su" },
            { "kind": "block", "type": "ad" },
            { "kind": "block", "type": "xr" },
            { "kind": "block", "type": "or" },
            { "kind": "block", "type": "an" },
            { "kind": "block", "type": "sa" },
            { "kind": "block", "type": "lm" },
            { "kind": "block", "type": "ld" },
            { "kind": "block", "type": "li" },
            { "kind": "block", "type": "jp" },
            { "kind": "block", "type": "np" },
            { "kind": "block", "type": "goto" }
          ]
        };

      // --- Blockly初期化 ---
      var workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox
      });

      // --- 変更があるたびにコード生成して出力 ---
      function updateCode() {
        var code = Blockly.Assembly.workspaceToCode(workspace);
        console.log('[DEBUG] 生成されたコード:', code);
        var outputDiv = document.getElementById('output');
        outputDiv.textContent = code;
        // スクロールして常に最新のコードが見えるようにする
        outputDiv.scrollTop = outputDiv.scrollHeight;
      }
      workspace.addChangeListener(updateCode);

      // アセンブリファイル保存機能
      async function saveAssemblyFile() {
        const code = Blockly.Assembly.workspaceToCode(workspace);
        
        if (!code || code.trim() === '') {
          alert('保存するアセンブリコードがありません。ブロックを配置してください。');
          return;
        }

        // Electronが利用可能かチェック
        if (typeof window.electronAPI !== 'undefined') {
          try {
            const result = await window.electronAPI.saveAssemblyFile(code);
            if (result.success) {
              alert('ファイルが保存されました: ' + result.filePath);
            } else if (result.canceled) {
              // ユーザーがキャンセルした場合は何もしない
            } else {
              alert('ファイルの保存に失敗しました: ' + result.error);
            }
          } catch (error) {
            alert('ファイル保存中にエラーが発生しました: ' + error.message);
          }
        } else {
          // ブラウザ環境の場合はダウンロード機能を提供
          const blob = new Blob([code], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'program.asm';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      }

      // ラベル作成ダイアログの制御
      function confirmLabelCreation() {
        var input = document.getElementById('labelInput');
        var newLabel = input.value;
        var dialog = document.getElementById('labelDialog');
        
        if (window.currentLabelBlock && newLabel && newLabel.trim()) {
          window.currentLabelBlock.handleNewLabel(newLabel.trim());
        } else if (window.currentLabelBlock) {
          // 空の場合は最初のラベルに戻す
          var field = window.currentLabelBlock.getField('LABEL');
          if (field && window.customLabels && window.customLabels.length > 0) {
            field.setValue(window.customLabels[0]);
          }
        }
        
        dialog.style.display = 'none';
        window.currentLabelBlock = null;
      }

      function cancelLabelCreation() {
        var dialog = document.getElementById('labelDialog');
        
        if (window.currentLabelBlock) {
          // キャンセルの場合は最初のラベルに戻す
          var field = window.currentLabelBlock.getField('LABEL');
          if (field && window.customLabels && window.customLabels.length > 0) {
            field.setValue(window.customLabels[0]);
          }
        }
        
        dialog.style.display = 'none';
        window.currentLabelBlock = null;
      }

      // Enterキーでの確定
      document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('labelInput').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            confirmLabelCreation();
          } else if (e.key === 'Escape') {
            cancelLabelCreation();
          }
        });
      });
    </script>
  </body>
</html>
